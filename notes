4 layers of comm
	app: user facing ; data-formatting, encryption, session management
	transport(TCP/UDP): transmission (softw); flow control, segmentation, reassembly
		TCP: connection oriented, reliable but slow (flow control, error checking, etc.)
		UDP: faster, connectionless transmission, no guarantees
	netw/internet(IP): navigator ; packet forwardingm fragmentation, logical addressing
		IP: assign unique IP addresses to devices, picks the most efficient path for data transmission
	netw access: physical transmission (hardw); MAC addressing, error detection at hardw link (Ethernet, WiFi etc.)

user data
==> app formats
==> broken up into packets, given headers and src/dst ports, picks TCP or UDP
==> adds the IP addresses to each packet, and picks its opt route
==> packets->frames, adds MAC addresses, sends data as binary bits
pick up
==> receives (frames->packets ?)
==> checks IP addresses, removes, IP header
==> reassembles TCP segs in order, checks data integrity
==> delivers data to app for reception
reaction

pushd <filename>.html;  python3 -m http.server 9999; popd;
==>running html, then c/v into browser

subnet masks :: 
divides up the IP address into host : 255, and device 0;
standard home mask 255.255.255.0, so if home computer 192.0.5.63, then home alexa 192.0.5.?
IPs can be divided binarily, too. so, home computer IP :
11000000.00000000.00000101.00111111
1, 2, 4, 8, 16, 32, 64, 128
